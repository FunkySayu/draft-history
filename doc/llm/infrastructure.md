# LLM Infrastructure Overview

This document provides an overview of the infrastructure setup for the League of Legends Champion Pick Rate History application. The setup is designed to be containerized using Docker and orchestrated with Docker Compose, facilitating ease of development, deployment, and scaling.

## Core Components

The application consists of three main services:

1.  **API Service (`api`)**:
    *   **Technology**: Python Flask application.
    *   **Functionality**: Provides backend logic and data access. Exposes RESTful endpoints (e.g., `/api/echo`).
    *   **Database**: Uses SQLAlchemy as an ORM. Configured to use a SQLite database by default, with the database file stored in a Docker named volume for persistence (`api_db_data`). It can be configured via environment variables (`DATABASE_URL`) to connect to other SQL databases like PostgreSQL.
    *   **Containerization**: Defined in `api/Dockerfile`. Uses a Python base image, installs dependencies from `api/requirements.txt`, and runs the Flask app using Gunicorn.
    *   **Development**: Source code from the local `./api` directory is mounted into the container for live updates (though Gunicorn might need a reload flag or a dev server like `flask run` for true live reload of Python code without restarting the process).

2.  **UI Service (`ui`)**:
    *   **Technology**: Angular application.
    *   **Functionality**: Provides the frontend user interface for interacting with the application. Communicates with the API service for data.
    *   **Containerization**: Defined in `ui/Dockerfile`. This is a multi-stage Docker build:
        *   Stage 1 (`build`): Uses a Node.js image to install Angular dependencies (from `ui/package.json`) and build the Angular application for production (`npm run build`).
        *   Stage 2: Uses an Nginx Alpine image to serve the static files generated by the Angular build process.
    *   **Development**: The local `./ui` directory is mounted into the container. However, for changes to be reflected, the Angular app needs to be rebuilt. The current Docker setup serves a static build; for a live-reload development server (`ng serve`), the Dockerfile and service definition in `docker-compose.yml` would need to be adapted (e.g., using a development-specific Dockerfile or Compose override).

3.  **Nginx Service (`nginx`)**:
    *   **Technology**: Nginx web server.
    *   **Functionality**: Acts as a reverse proxy and the main entry point for the application.
        *   Routes requests starting with `/api/` to the **API service** (running on port 5000 internally).
        *   Routes all other requests (e.g., `/`, `/home`) to the **UI service** (which is itself an Nginx server serving Angular static files on port 80 internally).
        *   Handles SPA routing requirements (e.g., `try_files $uri $uri/ /index.html;`) for the Angular application.
    *   **Configuration**: Uses a custom Nginx configuration file (`nginx.conf`) mounted into the container.
    *   **Port Mapping**: Exposes port `8080` on the host, which maps to port `80` inside the Nginx container. This is the primary port to access the application.

## Docker Compose (`docker-compose.yml`)

*   **Orchestration**: Defines and manages the multi-container application.
*   **Services**: Configures the `api`, `ui`, and `nginx` services, including their build contexts, Dockerfiles, ports, volumes, and environment variables.
*   **Networking**: Docker Compose automatically sets up a default network, allowing services to discover and communicate with each other using their service names (e.g., `api` service is reachable at `http://api:5000` from the `nginx` service).
*   **Volumes**:
    *   `api_db_data`: A named volume used to persist the SQLite database for the `api` service.
    *   Source code mounts (`./api:/app`, `./ui:/app`): Used during development to reflect local code changes into the containers. For production, these would typically be removed, and the code would be baked into the image.
    *   Nginx configuration mount (`./nginx.conf:/etc/nginx/nginx.conf:ro`): Mounts the custom Nginx configuration.

## Workflow

1.  **Build**: `docker-compose build` (or `docker-compose up --build`) builds the images for the `api` and `ui` services based on their respective Dockerfiles.
2.  **Run**: `docker-compose up` starts all defined services.
3.  **Access**: Users access the application via `http://localhost:8080` (or the configured host port for the `nginx` service).
4.  **Data Flow (Example: Echo component)**:
    1.  User types a message in the Angular UI and clicks "Send".
    2.  Angular component calls its `EchoService`.
    3.  `EchoService` makes an HTTP POST request to `/api/echo`.
    4.  The browser sends this request to `http://localhost:8080/api/echo`.
    5.  The host Nginx service (`nginx`) receives the request.
    6.  Based on `nginx.conf`, the location `/api/` is proxied to `http://api:5000/echo/`.
    7.  The Flask `api` service receives the request, processes it in the `/echo` route, and returns a JSON response.
    8.  The response travels back through Nginx to the browser.
    9.  The Angular `EchoService` receives the response, and the component updates the UI to display it.

## Scalability and Deployment Considerations

*   **Stateless Services**: The `api` (if not using SQLite or if DB is external) and `ui` services are largely stateless, making them easier to scale horizontally by running multiple instances. The `nginx` service can also be scaled and load-balanced.
*   **Database**: For production, SQLite might be replaced with a more robust database system like PostgreSQL or MySQL, which could run as another Docker container or a managed cloud service. The `DATABASE_URL` environment variable allows for easy configuration.
*   **Environment Variables**: Configuration is managed through environment variables (e.g., `DATABASE_URL`, `FLASK_ENV`), which is a best practice for Dockerized applications.
*   **Production Builds**: The `ui/Dockerfile` already performs a production build for Angular (`npm run build -- --configuration production`). The `api/Dockerfile` uses Gunicorn, which is a production-ready WSGI server.
*   **HTTPS**: For production, TLS/SSL termination would typically be handled at a load balancer पानी (like AWS ELB) or directly by Nginx (requiring SSL certificate configuration).

This containerized setup provides a consistent, reproducible, and isolated environment for the application across different stages (development, testing, production).
